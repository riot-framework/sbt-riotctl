---
title: 'Deploying your code with Riot Control'
weight: 3
summary: Connecting to your Pi using RIoT Control
---

RIoT Control is a tool that automates the deployment of your Java code to a Raspberry Pi or similar device. It finds your device on a local network, copies your java archives to it, creates a service configuration file, and starts your application or sets it as a service.

Currently, it is only available as a plugin for the [SBT] build tool.

## Creating an empty RIoT project 

The easy way first: There's a template that will create an empty project that's already set up. After [installing sbt], execute the following from your root git directory or similar:

```
sbt new riot-framework/streams.g8
```

Check the template's [github template][streams.g8] for more details.

## Configuring your existing project to use RIoT Control 

If you have an existing SBT project, add `sbt-riotctl` to your `project/plugins.sbt`file:

```
addSbtPlugin("org.riot-framework" % "sbt-riotctl" % "0.3")
```

RIoT Control depends on SBT's `JavaServerAppPackaging`, and will only be active if you've enabled it in your `build.sbt`:

```
enablePlugins(JavaServerAppPackaging)
```

In general, RIoT Control will then try to use sane default for everything, including the host name, username, and password used to log in to your Pi (it will use Raspbian's defaults). If you need to override any of them, add the corresponding configuration to your project's settings in `build.sbt`, for example:

```scala
lazy val root = (project in file("."))
  .enablePlugins(JavaServerAppPackaging)
  .settings(
  
    // Deployment Targets (hostname, username, password):
    riotTargets := Seq(
      riotTarget("raspberrypi", "pi", "raspberry")
      ),

    // Port to use for remote debugging:
    riotDbgPort := 8000,

    // Packages and features needed by your code:
    riotPrereqs := "oracle-java8-jdk wiringpi",
    riotRequiresI2C := false,
    riotRequiresSPI := false
    
  )
```

## Deploying your application

RIoT Control will deploy the files generated by SBT in the `stage` directory, and use the scripts generated by `JavaServerAppPackaging` to start your Application.

To copy your application to your device and run it:

```
sbt riotRun
```
Then press [Return] twice to terminate it. 

To debug your application, similarly run:

```
sbt riotDebug
```
and point your Remote Debugger to the device's address and the port defined in the `riotDbgPort` setting (e.g. `raspberrypi.local:8000`).

If you want run the application in the background:

```
sbt riotStart
```
then stop it with:

```
sbt riotStop
```

Once you're happy with the result, you can enable the Service that RIoT has created for your Application, which will cause it to start automatically when your device boots:

```
sbt riotInstall
```
To disable it, use the command:

```
sbt riotUninstall
```

In general, if issuing more than one command, it's considerably faster to start SBT in interactive mode:

```
sbt
```

then enter the commands above (without sbt, for example just `riotRun`). This allows for quick development: Modify your code in the editor, then change to your terminal and execute `riotRun` in the interactive SBT shell.

Many IDE have some sort of plugin to integrate with SBT, speeding up the development cycle even more.

## What happens during deployment

RIoT control runs after `JavaServerAppPackaging`, and uses the files it generates.

First, it checks that the **prerequisite packages** defined in the `riotPrereqs` setting are installed (by default the JDK 8 and the WiringPi library), and otherwise installs them with `apt-get`. A local SOCKS5 proxy is started locally through which `apt-get` accesses the package repositories, so this step works even if your Pi has no direct internet access (this is often the case if it's connected directly to your laptop).

Then, it checks that certain **features**, such as **SPI** or **I2C** ports, are enabled, depending on the `riotRequires...` settings.

Next, the `stage` directory is copied, in which `JavaServerAppPackaging` has built or copied all JARs, and generated start scripts. The target directory on the Pi is `/usr/local/` followed by your project's name.

A systemd 'service unit configuration' file is generated in `/etc/systemd/system/` and named after your project (followed by `.service`, as is the convention).

This systemd service is then started, stopped, enabled or disabled depending on the RIoT Control command issued. 

## How RIoT Control finds your Pi

RIoT Control will first try to access your Raspberry Pi by Hostname (e.g. if it is called 'raspberrypi', RIoT Control will attempt to connect to `raspberrypi` and `raspberrypi.local`).

If this fails, then RIoT Control will attempt to use **mDNS** (a service provided by **Bonjour** / **Zeroconf**) to discover an SSH service with the name provided. If your Raspberry Pi has the Avahi service installed and running (this is the case by default), it will publish its SSH port this way, as well as its current IP address.

[sbt]: https://www.scala-sbt.org
[installing sbt]: https://www.scala-sbt.org/1.x/docs/Setup.html
[streams.g8]: https://github.com/riot-framework/streams.g8
[riot-core]: https://github.com/riot-framework/riot-core
[sbt-riot]: https://github.com/riot-framework/sbt-riotctl
[riot]: https://riot.community
[akka streams]: https://doc.akka.io/docs/akka/current/stream/stream-quickstart.html
[giter8]: http://www.foundweekends.org/giter8/
[systemctl]: https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units
